<!DOCTYPE html PUBLIC "XSLT-compat">
<!-- saved from url=(0090)http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/#source -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Polygonal Map Generation for Games</title><link rel="canonical" href="./Polygonal Map Generation for Games_files/saved_resource(1).html"><link rel="shortcut icon" href="http://www-cs-students.stanford.edu/~amitp/favicon.ico"><link href="./Polygonal Map Generation for Games_files/css" rel="stylesheet" type="text/css"><link rel="alternate" type="application/atom+xml" title="Blobs in Games - Atom" href="http://simblob.blogspot.com/feeds/posts/default"><meta name="verify-v1" content="82b+h1+tgwLrcTqTiJrqquMvoFVBwMwY11dx63m01zk="><meta name="robots" content="noodp"><link rel="stylesheet" href="./Polygonal Map Generation for Games_files/main.css" type="text/css"><meta name="viewport" content="width=500, maximum-scale=1.0"><link rel="apple-touch-icon" href="http://www-cs-students.stanford.edu/~amitp/red_blob.gif"><script type="text/javascript" async="" src="./Polygonal Map Generation for Games_files/cse.js"></script><script type="text/javascript" async="" src="./Polygonal Map Generation for Games_files/embed.js"></script><script src="./Polygonal Map Generation for Games_files/jsapi" type="text/javascript"></script><link type="text/css" href="./Polygonal Map Generation for Games_files/default+en.css" rel="stylesheet"><link type="text/css" href="./Polygonal Map Generation for Games_files/default.css" rel="stylesheet"><script type="text/javascript" src="./Polygonal Map Generation for Games_files/default+en.I.js"></script><script type="text/javascript" src="./Polygonal Map Generation for Games_files/search.I.js"></script><style type="text/css">
.gsc-control-cse {
font-family: Arial, sans-serif;
border-color: #FFFFFF;
background-color: #FFFFFF;
}
.gsc-control-cse .gsc-table-result {
font-family: Arial, sans-serif;
}
input.gsc-input, .gsc-input-box, .gsc-input-box-hover, .gsc-input-box-focus {
border-color: #D9D9D9;
}
input.gsc-search-button, input.gsc-search-button:hover, input.gsc-search-button:focus {
border-color: #999999;
background-color: #dddddd;
background-image: none;
filter: none;
}
.gsc-tabHeader.gsc-tabhInactive {
border-color: #CCCCCC;
background-color: #FFFFFF;
}
.gsc-tabHeader.gsc-tabhActive {
border-color: #CCCCCC;
border-bottom-color: #FFFFFF;
background-color: #FFFFFF;
}
.gsc-tabsArea {
border-color: #CCCCCC;
}
.gsc-webResult.gsc-result,
.gsc-results .gsc-imageResult {
border-color: #FFFFFF;
background-color: #FFFFFF;
}
.gsc-webResult.gsc-result:hover,
.gsc-imageResult:hover {
border-color: #FFFFFF;
background-color: #FFFFFF;
}
.gs-webResult.gs-result a.gs-title:link,
.gs-webResult.gs-result a.gs-title:link b,
.gs-imageResult a.gs-title:link,
.gs-imageResult a.gs-title:link b {
color: #000000;
}
.gs-webResult.gs-result a.gs-title:visited,
.gs-webResult.gs-result a.gs-title:visited b,
.gs-imageResult a.gs-title:visited,
.gs-imageResult a.gs-title:visited b {
color: #666666;
}
.gs-webResult.gs-result a.gs-title:hover,
.gs-webResult.gs-result a.gs-title:hover b,
.gs-imageResult a.gs-title:hover,
.gs-imageResult a.gs-title:hover b {
color: #000000;
}
.gs-webResult.gs-result a.gs-title:active,
.gs-webResult.gs-result a.gs-title:active b,
.gs-imageResult a.gs-title:active,
.gs-imageResult a.gs-title:active b {
color: #000000;
}
.gsc-cursor-page {
color: #000000;
}
a.gsc-trailing-more-results:link {
color: #000000;
}
.gs-webResult .gs-snippet,
.gs-imageResult .gs-snippet,
.gs-fileFormatType {
color: #666666;
}
.gs-webResult div.gs-visibleUrl,
.gs-imageResult div.gs-visibleUrl {
color: #003300;
}
.gs-webResult div.gs-visibleUrl-short {
color: #003300;
}
.gs-webResult div.gs-visibleUrl-short {
display: none;
}
.gs-webResult div.gs-visibleUrl-long {
display: block;
}
.gs-promotion div.gs-visibleUrl-short {
display: none;
}
.gs-promotion div.gs-visibleUrl-long {
display: block;
}
.gsc-cursor-box {
border-color: #FFFFFF;
}
.gsc-results .gsc-cursor-box .gsc-cursor-page {
border-color: #CCCCCC;
background-color: #FFFFFF;
color: #000000;
}
.gsc-results .gsc-cursor-box .gsc-cursor-current-page {
border-color: #CCCCCC;
background-color: #FFFFFF;
color: #666666;
}
.gsc-webResult.gsc-result.gsc-promotion {
border-color: #F6F6F6;
background-color: #F6F6F6;
}
.gsc-completion-title {
color: #000000;
}
.gsc-completion-snippet {
color: #666666;
}
.gs-promotion a.gs-title:link,
.gs-promotion a.gs-title:link *,
.gs-promotion .gs-snippet a:link {
color: #1155CC;
}
.gs-promotion a.gs-title:visited,
.gs-promotion a.gs-title:visited *,
.gs-promotion .gs-snippet a:visited {
color: #1155CC;
}
.gs-promotion a.gs-title:hover,
.gs-promotion a.gs-title:hover *,
.gs-promotion .gs-snippet a:hover {
color: #1155CC;
}
.gs-promotion a.gs-title:active,
.gs-promotion a.gs-title:active *,
.gs-promotion .gs-snippet a:active {
color: #1155CC;
}
.gs-promotion .gs-snippet,
.gs-promotion .gs-title .gs-promotion-title-right,
.gs-promotion .gs-title .gs-promotion-title-right * {
color: #333333;
}
.gs-promotion .gs-visibleUrl,
.gs-promotion .gs-visibleUrl-short {
color: #009933;
}
</style><style type="text/css">.gssb_c{border:0;position:absolute;z-index:989}.gssb_e{border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-webkit-box-shadow:0 2px 4px rgba(0,0,0,0.2);cursor:default}.gssb_f{visibility:hidden;white-space:nowrap}.gssb_k{border:0;display:block;position:absolute;top:0;z-index:988}.gsdd_a{border:none!important}.gsib_a{width:100%;padding:4px 6px 0}.gsib_a,.gsib_b{vertical-align:top}.gssb_a{padding:0 7px}.gssb_a,.gssb_a td{white-space:nowrap;overflow:hidden;line-height:22px}#gssb_b{font-size:11px;color:#36c;text-decoration:none}#gssb_b:hover{font-size:11px;color:#36c;text-decoration:underline}.gssb_g{text-align:center;padding:8px 0 7px;position:relative}.gssb_h{font-size:15px;height:28px;margin:0.2em;-webkit-appearance:button}.gssb_i{background:#eee}.gss_ifl{visibility:hidden;padding-left:5px}.gssb_i .gss_ifl{visibility:visible}a.gssb_j{font-size:13px;color:#36c;text-decoration:none;line-height:100%}a.gssb_j:hover{text-decoration:underline}.gssb_l{height:1px;background-color:#e5e5e5}.gssb_m{color:#000;background:#fff}.gsq_a{padding:0}.gscsep_a{display:none}.gsfe_a{border:1px solid #b9b9b9;border-top-color:#a0a0a0;box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);}.gsfe_b{border:1px solid #4d90fe;outline:none;box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);}.gscb_a{display:inline-block;font:27px/13px arial,sans-serif}.gsst_a .gscb_a{color:#a1b9ed;cursor:pointer}.gsst_a:hover .gscb_a,.gsst_a:focus .gscb_a{color:#36c}.gsst_a{display:inline-block}.gsst_a{cursor:pointer;padding:0 4px}.gsst_a:hover{text-decoration:none!important}.gsst_b{font-size:16px;padding:0 2px;user-select:none;-webkit-user-select:none;white-space:nowrap}.gsst_e{opacity:0.55;}.gsst_a:hover .gsst_e,.gsst_a:focus .gsst_e{opacity:0.72;}.gsst_a:active .gsst_e{opacity:1;}.gsst_f{background:white;text-align:left}.gsst_g{background-color:white;border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-webkit-box-shadow:0 2px 4px rgba(0,0,0,0.2);margin:-1px -3px;padding:0 6px}.gsst_h{background-color:white;height:1px;margin-bottom:-1px;position:relative;top:-1px}.gssb_a{padding:0 9px}.gsib_a{padding-right:8px;padding-left:8px}.gsst_a{padding-top:3px}.gssb_e{border:0}.gssb_l{margin:5px 0}.gssb_c .gsc-completion-container{position:static}.gssb_c{z-index:5000}.gsc-completion-container table{background:transparent;font-size:inherit;font-family:inherit}.gssb_c > tbody > tr,.gssb_c > tbody > tr > td,.gssb_d,.gssb_d > tbody > tr,.gssb_d > tbody > tr > td,.gssb_e,.gssb_e > tbody > tr,.gssb_e > tbody > tr > td{padding:0;margin:0;border:0}.gssb_a table,.gssb_a table tr,.gssb_a table tr td{padding:0;margin:0;border:0}</style></head><body class="gameprog"><header><h1 role="banner">Polygonal Map Generation for Games<div class="subheading">from <a href="http://www.redblobgames.com/">Red Blob Games</a></div></h1><nav role="navigation"><ul><li>Home:</li><li class="nav"><a rel="me" href="http://www-cs-students.stanford.edu/~amitp/">Main →</a></li><li class="nav"><a href="http://amitp.blogspot.com/">Blog →</a></li><li class="nav omit-if-narrow"><a href="http://friendfeed.com/amitp">Links →</a></li><li><strong>Games:</strong></li><li class="nav navself"><a href="http://www-cs-students.stanford.edu/~amitp/gameprog.html">Main
                      →</a></li><li class="nav"><a href="http://simblob.blogspot.com/">Blog →</a></li><li class="nav omit-if-narrow"><a href="http://pinboard.in/u:amitp/t:gameprogramming/">Links →</a></li></ul></nav></header><div class="main" role="main"><p></p><address>4 Sep 2010</address><p></p><div class="topic"><p>I wanted to generate interesting game maps that weren’t constrained to be realistic, and I wanted to try some techniques I hadn’t tried before. I usually make tile maps but this time I decided to make polygonal maps. Instead of 1,000,000 tiles, what could I do with 1,000 polygons? I think the distinct player-recognizable areas might be useful for gameplay: locations of towns, places to quest, territory to conquer or settle, pathfinding waypoints, difficulty zones, etc. Once I have the polygons I can rasterize it back to tiles (or voxels), but I wanted to first generate the structure.</p><p>There were three main things I wanted: good coastlines, mountains and rivers. For the coastline, I wanted to make island maps that are surrounded by ocean, so that I don’t have to deal with people walking to the edge of the map. For the mountains, I started with something simple: mountains are whatever’s farthest from the coastline (this simple approach works for the islands produced here but we’d need something more clever to adapt this technique to generate continents). For the rivers, I started with something simple: draw rivers from the coast to the mountains.</p><p>First, <strong><a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/mapgen2.swf">try the demo</a>!</strong> (Flash) Read on to learn how it works, or get the <a href="./Polygonal Map Generation for Games_files/Polygonal Map Generation for Games.html">source code</a>. Here’s an example of the kinds of maps I want to produce:</p><p><a href="./Polygonal Map Generation for Games_files/voronoi-map-goal-16000-shaded.png"><img src="./Polygonal Map Generation for Games_files/voronoi-map-goal-16000-shaded.png" style="max-width:100%" alt="Goal of map generation project"></a></p><p>This page is a longer version of three blog posts on the topic: <a href="http://simblob.blogspot.com/2010/09/polygon-map-generation-part-1.html">part 1</a> is about polygons, map representation, islands, oceans and lakes and beach and land; <a href="http://simblob.blogspot.com/2010/09/polygon-map-generation-part-2.html">part 2</a> is about elevations, rivers, moisture, and biomes; and <a href="http://simblob.blogspot.com/2010/09/polygon-map-generation-part-3.html">part 3</a> is about rendering, demo, and source code.</p></div><div class="h2banner"><h2>Polygons</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>The first step is to generate some polygons. The simplest approach would be to use a hexagonal grid and perturb it a bit to make it look irregular. This works, but I wanted something even less regular than that, so I picked random points and generated <a href="http://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi polygons</a>, which are used for <a href="http://www.voronoi.com/wiki/index.php?title=Voronoi_Applications">lots of things</a>, including maps. The <a href="http://www.voronoi.com/wiki/index.php?title=VoroWiki_main_page">Voronoi wiki</a> is incomplete but has some useful background. I’m using nodename’s <a href="http://nodename.github.com/as3delaunay/">as3delaunay library</a>, which has an implementation of <a href="http://en.wikipedia.org/wiki/Fortune's_algorithm">Fortune’s Algorithm</a>.</p><p>Here’s an example of random dots (red) and the polygons that result:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/voronoi-polygons.png" alt="Voronoi diagram"><p>The polygon shapes and sizes are a bit irregular. Random numbers are more “clumpy” than what people expect. I want something closer to semi-random “blue noise”, or <a href="http://bit-player.org/2011/a-slight-discrepancy">quasirandomness</a>, not random points. I approximate that by using a variant of <a href="http://en.wikipedia.org/wiki/Lloyd's_algorithm">Lloyd relaxation</a>, which is a fairly simple tweak to the random point locations to make them more evenly distributed. Lloyd relaxation replaces each point by the <a href="http://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon">centroid</a> of the polygon. In my code I merely average the corners (see <code>improveRandomPoints</code>). Here’s the result after running approximate Lloyd relaxation twice:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/voronoi-2-lloyd.png" alt="Voronoi diagram with Lloyd relaxation run twice"><p>Compare it to running <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/voronoi-1-lloyd.png">once</a> or <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/voronoi-50-lloyd.png">fifty times</a>. The more iterations, the more regular the polygons get. Running it twice gives me good results but every game will vary in its needs.</p><p>Polygon sizes are improved by moving polygon centers. The same approach works to improve edge lengths. Moving corners by averaging the nearby centers produces more uniform edge lengths, although it occasionally worsens the polygon sizes. In the code, see the <code>improveCorners</code> function. However, moving corners will lose the Voronoi diagram properties. Those properties aren’t used in this map generator, but keep this in mind if you want to use those properties in a game. You can either get better edge lengths or you can preserve the Voronoi distance properties.</p><p>Using Voronoi adds some complexity so if you want to start with something simpler, try starting with a hexagnal grid or randomly perturbed hexagonal grid. The rest of the techniques in this article will also work with a hexagonal grid.</p></div><div class="h2banner"><h2>Map Representation</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>I’m representing the map as two related <a href="http://en.wikipedia.org/wiki/Graph_theory">graphs</a>: nodes and edges. The first graph has nodes for each polygon and edges between adjacent polygons. It represents the <a href="http://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation</a>, which is useful for anything involving adjacency (such as pathfinding). The second graph has nodes for each polygon <em>corner</em> and edges between corners. It contains the shapes of the Voronoi polygons. It’s useful for anything involving the shapes (such as rendering borders).</p><p>The two graphs are related. Every triangle in the Delaunay triangulation corresponds to a polygon corner in the Voronoi diagram. Every polygon in the Voronoi diagram corresponds to a corner of a Delaunay triangle. Every edge in the Delaunay graph corresponds to an edge in the Voronoi graph. You can see this in the following diagram:</p><img src="./Polygonal Map Generation for Games_files/edge-duality.png" alt="Diagram showing how Voronoi and Delaunay are related"><p>Polygon <code>A</code> and <code>B</code> are adjacent to each other, so there is a (red) edge between <code>A</code> and <code>B</code> in the adjacency graph. For them to be adjacent there must be a polygon edge between them. The (blue) polygon edge connects corners <code>1</code> and <code>2</code> in the Voronoi shape graph. <em>Every</em> edge in the adjacency graph corresponds to exactly one edge in the shape graph.</p><p>In the Delaunay triangulation, triangle <code>A</code>-<code>B</code>-<code>C</code> connects the three polygons, and can be represented by corner <code>2</code>. Thus, corners in the Delaunay triangulation are polygons in the Voronoi diagram, and vice versa. Here’s a larger example showing the relationship, with Voronoi polygon centers in red and corners in blue, and the Voronoi edges in white and the Delaunay triangulation in black:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/voronoi-and-delaunay.png" alt="Example Voronoi diagram with Delaunay overlay"><p>This duality means that I can represent the two graphs together. There are <a href="http://www.voronoi.com/wiki/index.php?title=PAN_graphs">several approaches</a> for combining the data from the two graphs. In particular, <a href="http://www.voronoi.com/wiki/index.php?title=Spatial_Data_Structures">edges can be shared</a>. Each edge in a normal graph points to two nodes. Instead of representing two edges in the two graph separately, I made edges point to <em>four</em> nodes: two polygon centers and two corners. It turns out to be quite useful to connect the two graphs together.</p><p>With the combined representation, I can now use the Relationships Between Grid Parts sections of my <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/grids/#relationships">article on grids</a>. They’re not grids so I’m not assigning grid coordinates, but many of the algorithms that work on grids also work here, and the algorithms that work on graphs also work here (on either of the two graphs).</p><p>In the code, the <code>graph/</code> directory has three classes: <code>Center</code>, <code>Corner</code>, and <code>Edge</code>:</p><ul><li><code>Center.neighbors</code> is a set of adjacent polygons</li><li><code>Center.borders</code> is a set of bordering edges</li><li><code>Center.corners</code> is a set of polygon corners</li><li><code>Edge.d0</code> and <code>Edge.d1</code> are the polygons connected by the Delaunay edge</li><li><code>Edge.v0</code> and <code>Edge.v1</code> are the corners connected by the Voronoi edge</li><li><code>Corner.touches</code> is a set of polygons touching this corner</li><li><code>Corner.protrudes</code> is a set of edges touching the corner</li><li><code>Corner.adjacent</code> is a set of corners connected to this one</li></ul></div><div class="h2banner"><h2>Islands</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>The second step is to draw the coastline. I used a simple function to divide the world into land and water. There are many different ways to do this. You can plug in your own shapes (<a href="http://www.reddit.com/r/rpg/comments/187o0v/im_not_sure_what_other_folks_do_but_this_is_how_i/">even if they come from pizza boxes</a>), although that code is not included in the demo. The map generator works with any division of points, but it forces the outer layer of polygons to be ocean. Here’s an example that divides the world into land and water:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/voronoi-land-water.png" alt="Polygon map with land and water chosen"><p>In the code, <code>Map.as</code> contains the core map generation code. The <code>IslandFunction</code> returns <code>True</code> if a position is land, and <code>False</code> for water. There are four island functions included in the demo:</p><ul><li><code>Radial</code> uses sine waves to produce a round island</li><li><code>Perlin</code> uses Perlin noise to control the shape</li><li><code>Square</code> fills the entire map with land</li><li><code>Blob</code> draws my <a href="http://www-cs-students.stanford.edu/~amitp/red_blob.gif">blob logo</a></li></ul><p>The code assigns water/land to both polygon centers and corners:</p><ol><li>Assign water/land to the <em>corners</em> by setting <code>Corner.water</code> based on the <code>IslandFunction</code>.</li><li>Assign water/land to the <em>polygons</em> by setting <code>Center.water</code> if some fraction of the corners have <code>water</code> set.</li></ol><p>A simple flood fill starting from the border of the map can determine which water areas are oceans (connected to the border) and lakes (surrounded by land):</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/voronoi-land-ocean-lake.png" alt="Polygon map divided into land, ocean, and lake"><p>In the code, the flood fill runs on the polygon centers, and then we can decide what happens to corners:</p><ol><li>Set <code>Center.ocean</code> for any polygon connected to the borders of the map through water polygons. If <code>Center.water</code> is set but <code>.ocean</code> is not, then it’s a lake.</li><li>Set <code>Center.coast</code> if the polygon is land but has an ocean border. Coastal areas will later get drawn as beaches.</li><li>Set <code>Corner.ocean</code> if the corner is surrounded by ocean polygons.</li><li>Set <code>Corner.coast</code> if the corner touches ocean and land polygons.</li><li>Reset <code>Corner.water</code> to be consistent with the surrounding area.</li></ol></div><div class="h2banner"><h2>Elevation</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>The most realistic approach would have been to define elevation first, and then define the coastline to be where the elevation reaches sea level. Instead, I’m starting with the goal, which is a good coastline, and working backwards from there. I set elevation to be the <strong>distance from the coast</strong>. I originally tried elevations at polygon centers but setting elevations at corners worked out better. Corner-to-corner edges can serve as ridges and valleys. After calculating the elevation of corners (<code>Corner.elevation</code>), the polygon elevation (<code>Center.elevation</code>) is the average of the elevation at the corners. See the functions <code>Map.assignCornerElevations</code> and <code>Map.assignPolygonElevations</code>.</p><p>Water polygons don’t count towards the distance. This is both because I expect lakes to be flat instead of sloped, and because this tends to build valleys around lakes, which helps guide rivers towards lakes.</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/elevations.png" alt="Elevation map"><p>One problem with the simple definition is that some islands have too many mountains and others have too few. To fix this, I redistribute the elevations to match a desired distribution, which has more low elevation land (coastline) than high elevation land (mountains). First, I sort the corners by elevation, and then I reset the elevation <code>x</code> of each to match the inverse of the desired cumulative distribution: <code>y(x) = 1 - (1-x)^2</code>. In the <code>Map.redistributeElevations</code> function, <code>y</code> is the position in the sorted list, and <code>x</code> is the desired elevation. Using the quadratic formula, I can solve for <code>x</code>. This preserves ordering so that elevations always increase from the coast to the mountains.</p><p>For any location, going downhill will eventually lead to the ocean. This diagram shows the steepest downhill direction from every corner, stored in <code>Corner.downslope</code>:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/downslopes.png" alt="Elevation map with arrows pointing downhill"><p>By following the downhill arrows from any location, we eventually reach the ocean. This will be useful for rivers but may also be useful for calculating <a href="http://www.voronoi.com/wiki/index.php?title=Rivers_and_watersheds">watersheds</a> and other features.</p><p>I had two main goals for elevation:</p><ol><li><strong>Biome</strong> types: high elevations get snow, rock, tundra; medium elevations get shrubs, deserts, forests, and grassland; low elevations get rain forests, grassland, and beaches.</li><li><strong>Rivers</strong> flow from high elevations down to the coast. Having elevations that always increase away from the coast means that there’s no local minima that complicate river generation.</li></ol><p>In addition, games may define their own use of elevation data. For example, <a href="http://www.realmofthemadgod.com/">Realm of the Mad God</a> uses elevation to distribute monsters.</p><p>This elevation calculation works for simple islands, which is what I needed for Realm of the Mad God. For continent generation, you’ll want to change this step to generate one or more mountain ranges that aren’t necessarily in the center, as well as isolated volcanos.</p></div><div class="h2banner"><h2>Rivers</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>Rivers and lakes are the two fresh water features I wanted. The most realistic approach would be to define moisture with wind, clouds, humidity, and rainfall, and then define the rivers and lakes based on where it rains. Instead, I’m starting with the goal, which is good rivers, and working backwards from there.</p><p>The island shape determines which areas are water and which are land. Lakes are water polygons that aren’t oceans.</p><p>Rivers use the downhill directions shown earlier. I choose random corner locations in the mountains, and then follow the <code>Corner.downslope</code> path down to the ocean. The rivers flow from corner to corner:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/river.png" alt="Elevation map with one river"><p>I tried both polygon centers and corners, but found that the corner graph made for much nicer looking rivers. Also, by keeping lakes flat, elevation tends to be lower near lakes, so rivers naturally flow into and out of lakes. Multiple rivers can share the lower portion of their path. Every time a river flows through an edge, I increase the water volume stored in <code>Edge.river</code> by 1. At rendering time, the river width is the square root of the volume. This approach is simple and works well.</p></div><div class="h2banner"><h2>Moisture</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>Since I’m working backwards, I don’t need moisture to form rivers. However, moisture would be useful for defining <strong>biomes</strong> (deserts, swamps, forests, etc.). Since rivers and lakes should form in areas with high moisture, I defined moisture to decrease as <strong>distance from fresh water</strong> increases. <code>Corner.moisture</code> is set to <code>a^k</code> for some <code>a</code> &lt; 1 (e.g. 0.95), and <code>k</code> being the distance. There are unfortunately some tuning parameters in <code>Map.assignCornerMoisture</code> that I tweaked until the maps looked reasonable:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/moisture.png" alt="Moisture map"><p>As with elevation, I redistribute moisture to match a desired distribution. In this case, I want roughly equal numbers of dry and wet regions. The desired cumulative distribution is <code>y(x) = x</code>, so the redistribution code is very simple. I sort by moisture and then assign the moisture of each corner to that corner’s position in the sorted list. See <code>Map.redistributeMoisture</code> for the code.</p><p>In this map generator, moisture is only used for biomes. However, games may find other uses for the moisture data. For example, <a href="http://www.realmofthemadgod.com/">Realm of the Mad God</a> uses moisture and elevation to distribute vegetation.</p></div><div class="h2banner"><h2>Biomes</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>Together, elevation and moisture provide a good amount of variety to define biome types. I use elevation as a proxy for temperature. If this were a continent generator, latitude might be a contributor to temperature. Also, wind, evaporation, and rain shadows might be useful for transporting moisture as humidity. However, for this generator I kept it simple. Biomes first depend on whether it’s water or land:</p><ul><li><code>OCEAN</code> is any water polygon connected to the map border</li><li><code>LAKE</code> is any water polygon not connected to the map border, or <code>ICE</code> lake if the lake is at high elevation (low temperature), or <code>MARSH</code> if it’s at low elevation</li><li><code>BEACH</code> is any land polygon next to an ocean</li></ul><p>For all land polygons, I started with the <a href="http://www.marietta.edu/~biol/biomes/biome_main.htm">Whittaker diagram</a> and adapted it to my needs:</p><div><table class="standard" width="100%" style="font-size:small"><thead><tr><th width="10%" rowspan="2">Elevation<br>Zone</th><th colspan="6">Moisture Zone</th></tr><tr><th width="15%">6<br>(wet)</th><th width="15%">5</th><th width="15%">4</th><th width="15%">3</th><th width="15%">2</th><th width="15%">1<br>(dry)</th></tr></thead><tbody style="text-align:center"><tr style="height:3em"><th>4<br>(high)</th><td style="background:#f8f8f8" colspan="3"><code>SNOW</code></td><td style="background:#ddddbb"><code>TUNDRA</code></td><td style="background:#bbbbbb"><code>BARE</code></td><td style="background:#999999"><code>SCORCHED</code></td></tr><tr style="height:3em"><th>3</th><td style="background:#ccd4bb" colspan="2"><code>TAIGA</code></td><td style="background:#c4ccbb" colspan="2"><code>SHRUBLAND</code></td><td style="background:#e4e8ca" colspan="2"><code>TEMPERATE DESERT</code></td></tr><tr style="height:3em"><th>2</th><td style="background:#a4c4a8"><code>TEMPERATE RAIN FOREST</code></td><td style="background:#b4c9a9" colspan="2"><code>TEMPERATE DECIDUOUS FOREST</code></td><td style="background:#c4d4aa" colspan="2"><code>GRASSLAND</code></td><td style="background:#e4e8ca"><code>TEMPERATE DESERT</code></td></tr><tr style="height:3em"><th>1<br>(low)</th><td style="background:#9cbba9" colspan="2"><code>TROPICAL RAIN FOREST</code></td><td style="background:#a9cca4" colspan="2"><code>TROPICAL SEASONAL FOREST</code></td><td style="background:#c4d4aa"><code>GRASSLAND</code></td><td style="background:#e9ddc7"><code>SUBTROPICAL DESERT</code></td></tr></tbody></table></div><p>Here’s the result:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/biomes.png" alt="Biome map"><p>These biomes look good in the map generation demo, but each game will have its own needs. <a href="http://www.realmofthemadgod.com/">Realm of the Mad God</a> for example ignores these biomes and uses its own (based on elevation and moisture).</p></div><div class="h2banner"><h2>Noisy Edges</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>For some games, the polygonal maps are sufficient. However, in other games I want to hide the polygon structure. The main way I do that is to replace the polygon borders with a noisy line. Why would I want a polygon structure if I’m just going to hide it? I think game mechanics and pathfinding benefit from the underlying structure.</p><p>Recall from earlier that there are <em>two</em> graphs: one for Voronoi corners (<code>1</code>, <code>2</code> in the diagram below) and edges (blue lines), and one for polycon centers (<code>A</code>, <code>B</code>) and Delaunay edges (red lines) between them:</p><img src="./Polygonal Map Generation for Games_files/edge-duality.png" alt="Diagram showing duality between edges in two graphs"><p>I wanted to make both types of line noisy without making them cross lines from other polygons. I also wanted to make them as noisy as feasible. I realized that points <code>A</code>, <code>1</code>, <code>B</code>, and <code>2</code> form a quadrilateral, and I could constrain the wanderings of the line segment to that quadrilateral:</p><img src="./Polygonal Map Generation for Games_files/edge-noisiness.png" alt="Diagram showing quadrilateral where noisy edges can be drawn"><p>I further divided the quadrilateral into four quadrilaterals. Two were usable for the red (Delaunay) edge and two for the blue (Voronoi) edge. As long as the lines stayed within their allocated space and met in the center, they’d never cross each other. That takes care of constraining them. Note that the quadrilateral may not be convex; to divide it properly, I divide it at the midpoint of the Voronoi edge instead of at the intersection of the Voronoi and Delaunay edges.</p><p>The entire map can be divided up into these quadrilateral regions, with no space left over:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/quad-markings.png" alt="Map area divided into quadrilaterals"><p>That ensures that the noisy lines aren’t constrained any more than necessary. (I wonder if these quadrilaterals would be useful for game mechanics.)</p><p>I can use any noisy line algorithm that fits within these constraints. I decided to subdivide the quadrilaterals recursively and stitch line segments together within the small quadrilaterals into a complete edge. The algorithm is in <code>NoisyEdges.as</code>, in <code>buildNoisyLineSegments</code>. The result is that the polygon edges are no longer straight:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/biomes-noisy.png" alt="Map with noisy biome boundaries"><p>There are three places to tune the noisiness:</p><ol><li>The recursive function ends when the segments are shorter than some length. I have examples at <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/biomes-noisy-7.png">segment size 7</a>, <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/biomes-noisy-4.png">segment size 4</a>, and <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/biomes-noisy-1.png">segment size 1</a>. In the map demo I use segment size 1 for rivers and coastlines, 3 where biomes meet, and 10 elsewhere.<br></li><li>There’s a tradeoff between how much of the space goes to the red quadrilaterals (Delaunay edges) and blue quadrilaterals (Voronoi edges). I set <code>NoisyEdges.NOISY_LINE_TRADEOFF</code> to 0.5.</li><li>There’s a range of random numbers in <code>NoisyEdges.subdivide</code>. In the current demo it’s from 0.2-0.8, but it can be up to 0.0–1.0. Also, the random numbers don’t have to be linearly chosen. More visual noise results if you avoid the space around 0.5.</li></ol><p>Noisy edges turn out to have a large impact on the map appearance, especially for rivers and coastlines.</p></div><div class="h2banner"><h2>More noise</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>I’m generally a fan of <a href="http://simblob.blogspot.com/2009/06/noise-in-game-art.html">noise in game art</a>, and wanted to add a little bit of noise to these maps as well. In a real game map the noise might reflect vegetation or small variations in terrain. In the demo (<code>mapgen2.as</code>) I just filled the screen with a random noise texture by adding a noise bitmap on top. I also smoothed the borders between adjacent polygons by blending the colors in stages:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/voronoi-map-goal.png" alt="Map with noisy boundaries and noise texture"><p>Here’s a rendering with 16,000 polygons, noisy edges, a noise texture overlay, and simple lighting:</p><img width="600" height="600" src="./Polygonal Map Generation for Games_files/voronoi-map-goal-16000-shaded.png" alt="Shaded map with 16,000 polygons"></div><div class="h2banner"><h2>Smooth biome transitions</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>A different way of blending the biomes at polygon boundaries is to build gradients using the elevation and moisture at each <em>corner</em>, and then assigning biomes per pixel:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/voronoi-map-goal-smooth.png" alt="Map with biomes computed per pixel"><p>If the game doesn’t need an entire polygon to be the same biome, this approach can be useful for making more interesting boundaries.</p></div><div class="h2banner"><h2>Distorted biome transitions</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>Another way to make the map look less polygon-like is to distort the elevation and moisture maps:</p><ol><li>Add Perlin or random noise to the elevation and moisture at each pixel.</li><li>Sample nearby points using Perlin or random noise to change the coordinate.</li></ol><p>Here’s an example of what this can do:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/voronoi-map-goal-distorted.png" alt="Map with distorted elevation and moisture"><p>Adding noise to the elevation and moisture will produce “dithering” in the zones near transitions. Sampling nearby points using noise will distort the shapes of the boundaries.</p></div><div class="h2banner"><h2 id="demo">Demo</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>I wrote a Flash demo to explore the generated maps:</p><img src="./Polygonal Map Generation for Games_files/mapgen2-ui.png" alt="Screenshot of mapgen2 demo"><p>The simplest way to explore the maps is to click Random and the various View options.</p><p><strong style="font-size:large"><a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/mapgen2.swf">Try the demo</a>!</strong></p><p>In a shape number like <code>85882-8</code>, 85882 chooses the overall island shape and 8 is the random number seed for the details (random points, noisy edges, rivers). You can type in a shape number and press Return to generate that map. The demo also shows one of several road algorithms, and an unfinished watershed detection algorithm which might be useful for assigning territorial control.</p></div><div class="h2banner"><h2 id="source">Source</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>I’ve placed the Actionscript source under the MIT license; it’s <a href="https://github.com/amitp/mapgen2">available on github</a>. If you can read Java or Javascript, I think you’ll have no trouble reading the Actionscript. I don’t expect that the code will be immediately useful to anyone, but it might be a useful starting point if you’d like to use these techniques for making your own game maps.</p><ul><li><code>Map.as</code> is the core map generation system</li><li><code>graph/*.as</code> is the representation of graphs (polygons, edges, corners)</li><li><code>mapgen2.as</code> is the demo, with rendering and GUI</li><li><code>Roads.as</code> is a module adding roads along contour lines</li><li><code>Lava.as</code> is a module adding lava fissures to high elevation edges</li><li><code>NoisyEdges.as</code> is used by the demo to build noisy edges</li></ul><p>The diagrams on this page are built with 300 polygons, the demo uses 2000, and the code can go much higher, although I’ve not tried above 16,000. Some of the code for producing diagrams isn’t checked in because it was quick and dirty code only for the diagrams on this page, and not generally useful.</p><p>If you find the code or ideas useful, I’d love to hear about it!</p><p>Jeff Terrace has contributed patches and also wrote <a href="https://github.com/jterrace/mapgen2/tree/utilities">a utility to convert the XML into COLLADA</a>, as well as <a href="http://ourbricks.com/viewer/c900247e00655090de931310a2a87931">a 3d rendering</a> in WebGL. Alex Schröder has been working on a <a href="http://www.flickr.com/photos/kensanata/5685579540/">Perl version</a> that generates SVG output. Christopher Garrett has written a <a href="https://github.com/czgarrett/delaunay-ios">Voronoi/Delaunay port for iOS</a>. Christophe Guebert has written a <a href="http://www.openprocessing.org/visuals/?visualID=30809">Java+Processing version</a>. Baran Kahyaoglu has written a <a href="http://www.barankahyaoglu.com/blog/post/2012/04/28/Map-Generator-source-code-is-available-now!.aspx">C#/ .NET version</a> (<a href="https://bitbucket.org/brnkhy/mapgeneratorxna">source</a>). <a href="http://gamedev.stackexchange.com/users/4708/chrish">Chris Herborth</a> has ported Baran’s code to <a href="https://github.com/Taffer/UnitySimpleMapGenerator">Unity</a>. Richard Janicek has a <a href="https://github.com/rjanicek/voronoi-map-haxe">Haxe version</a> that compiles to Javascript+Canvas, with a <a href="http://rjanicek.github.com/voronoi-map-haxe/">demo</a>. Егор Харват has a <a href="https://github.com/zaynyatyi/voronoi-map-nme">Haxe/NME version</a>. Phill Spiess also uses Voronoi and noisy edges for <a href="http://devblog.phillipspiess.com/projects/mapgen/">his project</a> but no details are posted.</p><p>The map generator wasn’t designed for use in campaign maps but Welsh Piper (<a href="http://www.welshpiper.com/nerd-therapy/">encounter tables</a>, <a href="http://www.welshpiper.com/minocra-campaign-map/">Minocra</a>) and <a href="http://kingdomsintrevail.blogspot.com/2012/02/caldera-birth-of-world.html">Kingdoms in Trevail</a> are using the map generator to create campaign maps.</p></div><div class="h2banner"><h2>Appendix: More map features</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><h3>Modules</h3><p>I tried to structure the map representation so that modules could annotate them without creating a code dependency. The GUI module <code>mapgen2.as</code> depends on <code>Map.as</code> (core) and <code>Roads.as</code> (non-core), but <code>Maps.as</code> does <em>not</em> depend on <code>Roads.as</code>. Every polygon, edge, and corner in the graph has an index, which can be used as a key into an external table. In <code>Roads.as</code>, there’s a <code>road</code> array that’s indexed by the edge index.</p><p>Where core map code can reference <code>edge.river</code> as a core field, the module can’t do that. Instead, the module references its local variable <code>road[edge.index]</code>. This works for polygon centers and corners as well. It keeps the core clean.</p><p>I have three modules: Roads, Lava, and NoisyEdges.</p><h3>Roads</h3><p>Realm of the Mad God doesn’t use most of the features of this map generator, but I built a road generator for them. I observed that in the game, people naturally explore rivers. This unfortunately leads them up to the mountains, where they die. I wanted to build some roads that are at right angles to the rivers.</p><p>I calculated contour lines along the corners. Where the contour level changes, there’s a road. It’s a fairly simple algorithm that works most of the time, but sometimes creates tiny loops:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/roads.png" alt="Roads drawn on a map"><p>Whereas rivers meander along Voronoi edges (blue lines in the diagram above), roads go on Delaunay edges (red lines). Roads don’t get the noisy edge treatment. Instead, they are drawn with splines from edge midpoint to midpoint:</p><img width="400" height="400" src="./Polygonal Map Generation for Games_files/roads-zoomed.png" alt="Close up view of road splines"><p>Most polygons have two neighbors with roads. For them, there’s a regular spline connecting the two edge midpoints. For polygons that have more than two road neighbors, I instead draw an intersection, with splines from all the edge midpoints to the polygon center. In the diagram above, the lower left polygon has an intersection and the upper right polygon has a regular spline.</p><h3>Lava</h3><p>Lava and rivers follow the same paths. Lava fissures occur in high dry areas, and are assigned to some subset of the edges. In a game, lava and water will of course be different, but here they only differ in color and placement. Lava gets the noisy edge treatment:</p><img width="375" height="300" src="./Polygonal Map Generation for Games_files/lava.png" alt="Close up of lava fissure"></div><div class="h2banner"><h2>Appendix: Future possibilities</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><h3>Abstract Rendering</h3><p>A <em>map</em> should show the relevant portions of the world, not all the details. With this projects I’m generating maps with some level of detail, but it’s not detailed down to the vegetation or towns, and it’s not completely abstract either. It may be possible to render a more abstract map in the style of maps of Middle Earth (such as <a href="http://geektyrant.com/news/2008/10/7/guillermo-del-toro-talks-about-the-entire-pentology-of-middl.html">this one</a>).</p><h3>Watersheds</h3><p>By following the downslope arrows (described in the section on elevation), there’s a path from every polygon corner, along edges, to the coast. I use this to mark every corner with the location where the water would flow out to the ocean. All corners with the same outflow location can be considered to be part of the same watershed.</p><p>The watershed code is incomplete. There’s a watershed view in the demo, but I’m not happy with it. I’ve tried polygon centers and corners as watershed boundaries and neither is quite right. I have put watershed calculations on hold until the day I need them.</p><p>The place I thought watersheds would be useful is for naming <a href="http://en.wikipedia.org/wiki/Drainage_basin">larger regions</a>. There are roughly 1000 land polygons on the map in the demo. In a game map it might be nice to have a smaller number of named regions that group together polygons. For example, the XYZ Mountains can be above the XYZ Valley, which might have the XYZ River flowing through it. Players would be able to learn that these features are related. I didn’t get very far with this project but I might come back to it someday.</p><h3>Impassable borders</h3><p>In this map generator all the borders between polygons are the same. There’s a smooth transition from one to the other. It might be interesting to make some edges discontinuous, so that we can make cliffs, chasms, plateaus, and other sudden elevation changes. See <a href="http://roguelikedeveloper.blogspot.com/2007/07/wilderness-generation-using-voronoi.html">this article</a> for ideas on how to make the Voronoi regions interesting for gameplay.</p><h3>Terrain analysis</h3><p>Pathfinding should be fairly fast on a polygonal map, and may be useful for terrain analysis. For example, if two locations are spatially close but pathwise far, that may mean there’s a bay or mountain in the way, and that’d be a good place for a tunnel or bridge. A pathfinder could also help find places where we need bridges to nearby islands. Polygons that show up on paths often might be strategically more valuable than polygons that rarely are used for paths.</p><h3>Named areas</h3><p>As mentioned in the watersheds section, I’d like to name map features. Combined with terrain analysis, names could be assigned to rivers, mountains, lakes, groups of polygons, coastlines, oceans, forests, peninsulas, valleys, etc. Names in an area could be related. For example, the XYZ River could flow from Mount XYZ through the XYZ Valley. I haven’t worked on this in part because I think it helps if it’s for a specific game instead of a generic map generator. Not only should names connect to the game’s theme, there could be items and quests and plot elements that are related. For example, the Sword of XYZ might be found only in the XYZ Valley.</p><h3>Variable density</h3><p>Fortune’s algorithm should work within a polygon to subdivide it into smaller polygons. A map where most of the world is coarse, but some areas are more finely divided, could be interesting. Alternatively, we could place the original points with variable density so that some areas get more polygons than others. For example, we could use <a href="http://www.devmag.org.za/articles/55-POISSON-DISK-SAMPLING/">Poisson Disk Sampling</a> instead of Lloyd’s Algorithm.</p><h3>Better noisy edges</h3><p>I implemented a very simple noisy edge system, with jagged lines. The corners are very visible when you zoom in on the map. A better system might involve curved splines, or a fractal expansion that looks more detailed as you zoom in.</p></div><div class="h2banner"><h2>Appendix: Process improvements</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>For those of you interested in how I got to this point, a brief history:</p><ul><li>In December 2009, Rob and Alex of Wild Shadow Studios had asked me if I had a quick way to generate maps. I had already been thinking about using Perlin noise for maps, so I tried it, with <a href="http://simblob.blogspot.com/2010/01/simple-map-generation.html">good results</a>. I got something going within a day, and then spent the next month tweaking and trying variations. Most of the variations failed, and taught me that there were limitations with this approach. One month was a good time to stop, so I stopped working on maps and moved on to other small projects — art, animation, monster groups, NPC AI, among others.</li><li>In June 2010, I was inspired to work on maps again. I spent the month sketching out ideas on paper and trying some prototypes. I tried hexagon grids, hexagonal river basins, quadrilateral river generation, volcanos, hills, erosion, weather systems, and a few other things. <strong>Everything failed.</strong> However, I learned a lot by trying these things out. Delaunay triangulations for example didn’t work out, but they led me to Voronoi diagrams. The quadrilateral river generation didn’t work out, but the quadrilaterals were useful later when I worked on noisy edges. The erosion system didn’t work out, but some of the same ideas were useful when I worked on rivers.</li><li>While attending the Procedural Content Generation workshop, I sketched out some more ideas on paper for map generation. During the July 4 long weekend, I implemented these, and they worked really well. I worked out Voronoi polygons, map representation, island generation, noisy edges, elevation, biomes, rivers, and elevation redistribution that weekend. I experienced <a href="http://en.wikipedia.org/wiki/Flow_(psychology)">flow</a>. It was great! Most of the core system was in place in just three days.</li><li>Every weekend in July and August, I made improvements, many of them substantial. I also made many changes that didn’t work out, and I deleted them. As the core map features became good, I shifted my focus to the map rendering and the UI. As the map rendering and UI improved, I was able to <em>see</em> more flaws in the maps, and I found lots more bugs I needed to fix. I also made major refactorings to simplify the code that had grown organically.</li><li>By the end of August I found that I was only working on minor things, and decided the project was ready to wrap up. I spent the Labor Day long weekend writing up the results on this page (and the blog posts). Much of my time went into making good diagrams. The diagrams actually exposed more bugs, and I ended up making bug fixes, greatly simplifying one feature (elevation redistribution), and implementing a new feature (moisture redistribution). I also renamed and commented code to make it easier to explain.</li></ul><p>Why am I keeping track of this? It’s because I’m trying to improve the process by which I approach these small (1-3 month) projects. There are some things I want to remember:</p><ol><li>It’s useful to have a <strong>key idea</strong> that drives everything else. The simple maps I did in January were based on Perlin Noise. These maps are based on Voronoi diagrams. I need to pick something and go with it, but only after…</li><li>It sometimes takes a <strong>lot of experimentation</strong> before I run across the right idea. I spent a month on ideas before coming up with Voronoi as the key structure. I need to sketch out lots and lots of ideas.</li><li>I have a <strong>lot of failures</strong>. The key is to fail quickly, not to avoid failing. I need to not get discouraged.</li><li>I got the core system up in three days. <strong>A quick prototype</strong> can tell me a lot about whether an idea’s going to work out. In the early stages I need to focus on a prototype and not worry about making it a high quality system.</li><li>In the very early phase it’s more important to <strong>learn from the system</strong> than to produce good code. I need to ask myself what I’m trying to learn with a prototype.</li><li><strong>Failures are sometimes useful later</strong>. I need to keep them accessible. I’ve been deleting the code as soon as it fails, but maybe I should make lots more git branches and store them there.</li><li>The <strong>ability to see things</strong> can help a great deal in understanding what’s going on. I missed several bugs because I never bothered to build a visualization for that part of the data. I need to display as much as I can.</li><li>There are sometimes <strong>tiny things that seem wrong</strong> that actually mean I have a bug somewhere. I often shrug these things off. Even if it’s not a good time to investigate and fix some bug, I need to track them somewhere so that I can later investigate.</li><li><strong>Writing the blog posts</strong> helped tremendously. It forced me to understand every part of the system, to look at all the data, and to make sure all the code could be understood. It made me question every phase of map generation and improve the ones that were hard to explain. I need to write blog posts much earlier in the process. Explaining is a good way to learn.</li></ol><p>I’ll keep these in mind as I work on future projects.</p></div><div class="h2banner"><h2>Appendix: References</h2><div class="h2-curl-bottom"></div><div class="h2-curl-top"></div></div><div class="topic"><p>Thanks to the <a href="http://www.dungeonleague.com/">Dungeon League blog</a> for a great series on procedural map generation, the <a href="http://pcg.wikidot.com/">Procedural Content Generation wiki</a> for <a href="http://pcg.wikidot.com/pcg-algorithm:map-generation">ideas for map generation</a>, the incomplete <a href="http://www.voronoi.com/wiki/index.php?title=VoroWiki_main_page">Voronoi wiki</a> for some useful resources about Voronoi diagrams.<br></p><p>My thanks to <code>nodename</code> for <a href="http://nodename.github.com/as3delaunay/">as3delaunay</a>. It’s an Actionscript 3 library for generating Voronoi and Delaunay graphs. Also my thanks to <code>polygonal</code> for the <a href="http://lab.polygonal.de/2007/04/21/a-good-pseudo-random-number-generator-prng/">PM_PRNG</a> random number library, which allows me to use and reset the seed value so that I can reproduce a series of pseudorandom numbers. I used the <a href="http://optipng.sourceforge.net/">OptiPNG library</a> to optimize the PNG images on this page.</p><p><a href="http://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation</a> and <a href="http://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi polygons</a> are taught in many graphics classes. For example, see <a href="http://graphics.stanford.edu/courses/cs368-06-spring/handouts/Delaunay_1.pdf">Stanford CS 368</a>(PDF). I also looked at <a href="http://en.wikipedia.org/wiki/Relative_neighborhood_graph">relative neighborhood graphs</a> and <a href="http://en.wikipedia.org/wiki/Gabriel_graph">Gabriel graphs</a> but didn’t use either.</p><p>Delaunay triangulation can be used for maps, in the form of <a href="http://en.wikipedia.org/wiki/Triangulated_irregular_network">triangular irregular networks</a>. Voronoi diagrams are also used for maps.</p><p><a href="http://en.wikipedia.org/wiki/Fortune's_algorithm">Fortune’s Algorithm</a> is one of several algorithms that can turn a set of points into Voronoi polygons. It’s implemented in <code>as3delaunay</code>. <a href="http://en.wikipedia.org/wiki/Lloyd's_algorithm">Lloyd Relaxation</a> is used to improve the distribution of random points. It decreases the irregularity of the Voronoi polygons.</p><p>The Voronoi wiki has some incomplete pages on <a href="http://www.voronoi.com/wiki/index.php?title=PAN_graphs">graph representation</a> and <a href="http://www.voronoi.com/wiki/index.php?title=Spatial_Data_Structures">edge representation</a>, as well two pages that helped me with river generation: <a href="http://www.voronoi.com/wiki/index.php?title=Rivers_and_watersheds">rivers and watersheds</a> and <a href="http://www.voronoi.com/wiki/index.php?title=Crust_and_Skeleton">crust and skeleton</a>.</p><p>The <a href="http://www.reliefshading.com/">Relief Shading Website</a> has some <a href="http://www.reliefshading.com/examples/index.html">images of shaded relief maps</a>, as well as design guidelines for shading and coloring. I am sad to say I did not have time to apply these techniques. I also studied Bing and Google maps to see how they draw various features; see <a href="http://web.archive.org/web/20101223024222/http://www.41latitude.com/post/897973389/bing-maps-redesign">this article</a> and <a href="http://amitp.blogspot.com/2007/09/online-map-sites.html">my blog post</a> and <a href="http://infosthetics.com/archives/2010/06/bing_destination_map_automatic_napkin_sketching_of_maps.html">this article</a>.</p><p>The <a href="http://www.marietta.edu/~biol/biomes/biome_main.htm">Whittaker diagram</a> is one way to predict common biomes given climate. Wikipedia has a page listing <a href="http://en.wikipedia.org/wiki/Biome">biome classification schemes and various biomes</a>.</p><p>Wikipedia also has a nice <a href="http://en.wikipedia.org/wiki/List_of_landforms">list of landforms</a> that one might want to generate in a game map generator. I did not explore these for this project.</p><p>Ken Perlin is the master of noise, with Perlin Noise. He’s also made the much lesser known <a href="http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">Simplex Noise</a>(PDF). For this project I used Perlin Noise for the overall island shape. Joe Slayton has a page on <a href="http://www.ridgenet.net/~jslayton/FunWithWilburVol6/">how to turn perlin noise into islands</a>. I was looking for “blue noise”, which led me to <a href="http://www.cs.virginia.edu/~gfx/pubs/antimony/">Dunbar and Humphreys’s paper on noise generation</a> and <a href="http://johanneskopf.de/publications/blue_noise/">recursive Wang tiles</a> before I found Lloyd’s algorithm for better random point distribution. I also looked at <a href="http://www.red3d.com/cwr/texsyn/diary.html">Craig Reynold’s textures</a> but didn’t have time to do anything with them.</p><p>Also interesting were <a href="http://liris.cnrs.fr/~egalin/articles.html">these papers about generating worlds</a>, <a href="http://www.gozzys.com/wilderness/wildmap.php">Gozzy’s wilderness map generator</a>, <a href="http://donjon.bin.sh/world/">donjon’s world generator</a>, a <a href="http://gram.cs.mcgill.ca/papers/rudzicz-08-iterated.pdf">paper on procedural road generation</a>, a <a href="http://www.vision.ee.ethz.ch/~pmueller/wiki/CityEngine/PaperCities">paper on procedural city generation</a>. <a href="http://en.wikipedia.org/wiki/Straight_skeleton">Straight skeletons</a> seemed like they might be useful for defining mountain ranges, but once I discovered how well “distance from coast” worked, I didn’t need anything else. The 3d map generation in <a href="http://www.bay12games.com/dwarves/">Dwarf Fortress</a> is pretty neat.</p></div><p></p></div><div class="divider"><div class="google-search"><div id="___gcse_0" dir="ltr"><form class="gsc-search-box gsc-search-box-tools" accept-charset="utf-8"><table cellspacing="0" cellpadding="0" class="gsc-search-box"><tbody><tr><td class="gsc-input"><div class="gsc-input-box" id="gsc-iw-id1"><table cellspacing="0" cellpadding="0" style="width: 100%; padding: 0px;" id="gs_id0" class="gstl_0 "><tbody><tr><td id="gs_tti0" class="gsib_a"><input autocomplete="off" type="text" size="10" class="gsc-input" name="search" title="search" style="width: 100%; padding: 0px; border: none; margin: 0px; height: auto; outline: none; background-image: url(http://www.google.com/cse/intl/en/images/google_custom_search_watermark.gif); background-color: rgb(255, 255, 255); background-position: 0% 50%; background-repeat: no-repeat no-repeat;" id="gsc-i-id1" dir="ltr" spellcheck="false"></td><td class="gsib_b"><div class="gsst_b" id="gs_st0" style="" dir="ltr"><a class="gsst_a" href="javascript:void(0)" style="display: none;"><span class="gscb_a" id="gs_cb0">×</span></a></div></td></tr></tbody></table></div></td><td class="gsc-search-button"><input type="image" src="./Polygonal Map Generation for Games_files/search_box_icon.png" class="gsc-search-button gsc-search-button-v2" title="search"></td><td class="gsc-clear-button"><div class="gsc-clear-button" title="clear results">&nbsp;</div></td></tr></tbody></table><table cellspacing="0" cellpadding="0" class="gsc-branding"><tbody><tr><td class="gsc-branding-user-defined"></td><td class="gsc-branding-text"><div class="gsc-branding-text">powered by</div></td><td class="gsc-branding-img"><img src="./Polygonal Map Generation for Games_files/small-logo.png" class="gsc-branding-img"></td></tr></tbody></table></form></div></div><div id="___gcse_1"><div class="gsc-control-cse gsc-control-cse-en"><div class="gsc-control-wrapper-cse" dir="ltr"><div class="gsc-results-wrapper-nooverlay"><div class="gsc-tabsAreaInvisible"><div class="gsc-tabHeader gsc-inline-block gsc-tabhActive">Custom Search</div><span class="gs-spacer"> </span></div><div class="gsc-tabsAreaInvisible"></div><div class="gsc-above-wrapper-area-invisible"><table cellspacing="0" cellpadding="0" class="gsc-above-wrapper-area-container"><tbody><tr><td class="gsc-result-info-container"><div class="gsc-result-info-invisible"></div></td></tr></tbody></table></div><div class="gsc-adBlockInvisible"></div><div class="gsc-wrapper"><div class="gsc-adBlockInvisible"></div><div class="gsc-resultsbox-invisible"><div class="gsc-resultsRoot gsc-tabData gsc-tabdActive"><table cellspacing="0" cellpadding="0" class="gsc-resultsHeader"><tbody><tr><td class="gsc-twiddleRegionCell"><div class="gsc-twiddle"><div class="gsc-title">Web</div></div><div class="gsc-stats"></div><div class="gsc-results-selector gsc-more-results-active"><div class="gsc-result-selector gsc-one-result" title="show one result">&nbsp;</div><div class="gsc-result-selector gsc-more-results" title="show more results">&nbsp;</div><div class="gsc-result-selector gsc-all-results" title="show all results">&nbsp;</div></div></td><td class="gsc-configLabelCell"></td></tr></tbody></table><div><div class="gsc-expansionArea"></div></div></div></div></div></div></div></div></div></div><div class="divider-disqus" style="font-size:large">
            Email me at
            
            <a class="email" href="mailto:amitp@cs.stanford.edu">amitp@cs.stanford.edu</a>,
              
            or post a public comment:
          </div><div class="comments main" role="complementary"><div id="disqus_thread"><iframe id="dsq1" data-disqus-uid="1" allowtransparency="true" frameborder="0" role="complementary" style="width: 100%; border: none; overflow: hidden; height: 5996px;" width="100%" src="./Polygonal Map Generation for Games_files/saved_resource.html" scrolling="no" horizontalscrolling="no" verticalscrolling="no"></iframe><iframe id="dsq3" data-disqus-uid="3" allowtransparency="true" frameborder="0" style="width: 100%; border: none; overflow: hidden; display: none;" width="100%" src="./Polygonal Map Generation for Games_files/client.html"></iframe><iframe id="dsq-indicator-north" data-disqus-uid="-indicator-north" allowtransparency="true" frameborder="0" role="alert" style="width: 995px; border: none; overflow: hidden; top: 0px; min-width: 995px; max-width: 995px; position: fixed; max-height: 29px; min-height: 29px; height: 29px; display: none;" scrolling="no"></iframe><iframe id="dsq-indicator-south" data-disqus-uid="-indicator-south" allowtransparency="true" frameborder="0" role="alert" style="width: 995px; border: none; overflow: hidden; bottom: 0px; min-width: 995px; max-width: 995px; position: fixed; max-height: 29px; min-height: 29px; height: 29px; display: none;" scrolling="no"></iframe></div><script type="text/javascript">
              (function() {
              var dsq = document.createElement('script');
              dsq.type = 'text/javascript'; dsq.async = true;
              
                  dsq.src = 'http://blobs.disqus.com/embed.js';
                
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
            </script><noscript>&lt;a href="http://blobs.disqus.com/?url=ref"&gt;View the discussion thread.&lt;/a&gt;</noscript></div><div class="footer" role="contentinfo"><div style="float:left;width:30em"><address>
		  Copyright © 2013
                  <span class="vcard"><a rel="copyright" class="url fn n" href="http://www-cs-students.stanford.edu/~amitp/"><span class="given-name"> Amit </span><span class="additional-name"> J </span><span class="family-name"> Patel</span></a>,
                          <a class="email" href="mailto:amitp@cs.stanford.edu">amitp@cs.stanford.edu</a></span></address></div><div style="clear:left"></div><!-- Start of counters --><script type="text/javascript"><!--
                  var sc_project=417499;
                  var sc_invisible=1;
                  var sc_security="";
(function() {
      var ga = document.createElement('script');
      ga.type = 'text/javascript'; ga.async = true;
      ga.src = 'http://statcounter.com/counter/counter_xhtml.js';
      document.getElementsByTagName('body')[0].appendChild(ga);
  })();
                //--></script><noscript>&lt;div class="statcounter"&gt;&lt;a class="statcounter" href="http://statcounter.com/"&gt;&lt;img class="statcounter" src="http://c.statcounter.com/417499/0//1/" alt=""&gt;&lt;/a&gt;&lt;/div&gt;</noscript><script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount',
    'UA-79181-1'
    ]);
      
  
      _gaq.push(['_setDomainName', 'stanford.edu']);
    
  _gaq.push(['_setAllowLinker', true]);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
        'http://www') + '.google-analytics.com/ga.js';
    ga.async = true;
    document.getElementsByTagName('body')[0].appendChild(ga);
  })();

  window.onerror = function(message, file, line) {
    _gaq.push(['_trackEvent', 'Errors', 'Browser', '[' + file + ' (' + line + ')] ' + message, null, true]);
  }
</script><!-- End of counters --><script>
(function() {
  var cx = '015053491556836196840:0hqisdtq4p0';
  var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
  gcse.src = (document.location.protocol == 'https' ? 'https:' : 'http:') +
      '//www.google.com/cse/cse.js?cx=' + cx;
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
})();
</script></div><script type="text/javascript" async="" src="./Polygonal Map Generation for Games_files/counter_xhtml.js"></script><script src="./Polygonal Map Generation for Games_files/ga.js" async=""></script>
<div id="GOOGLE_INPUT_CHEXT_FLAG" style="display: none;" input="" input_stat="{}"></div><table cellspacing="0" cellpadding="0" style="width: 280px; display: none; top: 25838px; position: absolute; left: 1195px;" class="gstl_0 gssb_c"><tbody><tr><td class="gssb_f"></td><td class="gssb_e" style="width: 100%;"></td></tr></tbody></table></body></html>